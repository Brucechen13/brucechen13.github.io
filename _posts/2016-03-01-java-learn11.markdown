---
layout:     post
title:      "深入理解JAVA虚拟机学习笔记"
subtitle:   "第12章 Java内存模型与线程"
date:       2016-03-01
author:     "brucechen"
header-img: "img/post-bg-java.jpg"
published: false
tags:
    - Java
    - 读书笔记
---

### 高速缓存
现代计算机为了解决处理器与内存之间的速度矛盾，加入了一层读写速度尽量接近处理器速度的高速缓存，作为内存与处理器之间的缓冲，将运算需要使用到的数据复制到缓存中，运算结束后再从缓存同步到内存中，这样处理器就不需要等待缓慢的内存读写了。
基于高速缓存的存储交互在提高效率的同时也引进了新的问题，那就是缓存一致性。多处理器系统中，每个处理器都有自己的缓存，缓存又共享同一主内存，当多个处理器运算涉及同一块主内存时，就会出现缓存数据与主内存数据一致性的问题。为了解决一致性的问题，需要各个处理器访问缓存时都遵循一些协议，在读写时要根据协议来进行操作，这类协议有MSI、MESI（Illinois Proto-col）、MOSI、Synapse、Firefly及Dragon Proto-col等。

### Java内存模型 
内存模型就是在特定的操作协议下，对特定的内存或高速缓存进行读写访问的过程抽象。Java虚拟机规范中试图定义一种Java内存模型（`Java Memory Model, JMM`）来屏蔽掉各种硬件和操作系统的内存访问差异，以实现让Java程序在各种平台下都能达到一致的内存访问效果。
Java内存模型的主要目标是定义程序中各个变量的访问规则，即在虚拟机中将变量存储到内存和从内存中取出变量这样的底层细节。这里的变量指的是存储在主内存中可能被其他线程访问的数据，包括实例字段，静态字段和数组对象。
Java内存模型规定所有变量存储在主内存中，每个线程还有自己的工作内存（类似处理器高速缓存），工作内存存储了该线程使用到的变量的主内存副本拷贝，线程对变量的所有操作都必须在工作内存进行，不能读写主内存中的变量。不同线程也无法访问对方工作内存中的变量。
Java内存模型定义了8种原子操作来实现从主内存和工作内存之间的数据交互。

* lock(锁定)：作用于主内存的变量，把变量表示为一条线程独占的状态
* unlock(解锁)：作用于主内存，把处于锁定状态的变量释放。
* read(读取)：作用于主内存，把一个变量的值从主内存传输到线程的工作内存，以便load动作使用。
* load(载入)：作用于工作内存，把read操作的变量值放入工作内存的变量副本中。
* use(使用)：作用于工作内存，把工作内存中一个变量的值传递给执行引擎，每当虚拟机遇到一个需要使用到变量的值的字节码指令都会执行这个操作。
* assign(赋值)：作用于工作内存，把一个从执行引擎接收到的值赋给工作内存的变量，每当虚拟机遇到一个给变量赋值的字节码指令时执行这个操作。
* store(存储)：作用于工作内存，把工作内存的变量值传送到主内存，以便write操作使用。
* write(写入)：作用于主内存的变量，把store操作从工作内存中得到的变量值放入主内存的变量中。

除此之外，Java内存模型还规定了执行上述操作时必须满足以下规则：

* 不允许read和load、store和write操作之一单独出现。
* 不允许一个线程丢弃它最近的assign操作，即变量在工作内存改变之后必须把变化同步到主内存。
* 不允许一个线程无原因的（没有发生过任何assign操作）把数据从线程的工作内存同步到主内存。
* 一个变量只能在主内存生成，不允许工作内存直接使用一个未被初始化（load和assign）的变量。
* 一个变量在同一时刻只允许一条线程对其进行lock操作，但lock操作可以被同一个线程重复执行，多次执行后只有执行相同次数的unlock操作，变量才会解锁。
* 对一个变量执行lock操作，将会清空工作内存中此变量的值，执行引擎使用这个变量前，需要重新执行load和assign操作初始化变量的值。
* 不允许对一个没有被lock操作锁定的变量执行unlock操作，也不允许去unlock其他线程锁定的变量。
* 对一个变量执行unlock操作前，必须把该变量同步到主内存。

#### volatile型变量
关键词volatile可以说是Java虚拟机提供的最轻量级同步机制，定义为volatile的变量具备两种特性：
1. 保证此变量对所有线程的可见性，即当一条线程修改了这个变量的值，新值对于其他线程是立即得知的，对volatile变量的所有写操作都能立刻反应到其他线程中。
2. 禁止指令重排序优化。

虽然volatile变量可以保证对所有线程的可见性，但并不能保证线程安全，如果A线程在加载变量后，B线程修改了变量，同步到主内存，然后A线程修改了加载后的变量，同步到主内存，这样就会出现数据一致性的问题。所以为了保证操作的原子性，必须符合以下规则：
* 运算结果不依赖变量的当前值，或者能够确保只有单一线程能修改变量的值。
* 变量不需要与其他状态变量共同参与不变约束。

#### long和double型变量的特殊规则
Java模型规定了8种原子操作，但是对于64位数据类型（long和double），特别定义了一条相对宽松的规定，允许虚拟机将没有被volatile修饰的64位数据的读写操作划分为两次32位的操作执行，即允许虚拟机实现不保证64位数据类型的load，store，read，write四个操作的原子性，这就是long和double的非原子行协定(`Nonatomic Treatment ofdouble and long Variables`)。
如果多个线程共享一个未被声明为volatile的long和double类型的变量并且同时对它们进行读取和修改操作，那么某些线程可能会读取到既非原值，也不是其他线程修改值的“半个变量”的数值。
不过目前主流的虚拟机实现都会把64位数据的读写操作当作原子操作来实现。

#### 原子性、可见性和有序性

* 原子性：Java内存模型直接保证的原子性操作包括read、load、assign、use、store、write。如果应用场景还需要更大范围的原子性保证，可以使用lock、unlock操作来满足这种需求，对应的Java代码就是synchronized关键字。
* 可见性：可见性就是当一个线程修改了共享变量的值，其他线程可以立刻得知这个修改。volatile变量可以保证多线程操作变量的可见性，synchronized可以保证对一个变量执行unlock操作之前，必须把此变量同步回主内存。final修饰的字段可以保证一段初始化完成，那么其他线程都能看见final字段的值。
* 有序性：如果在本线程观察，所有操作都是有序的，如果从其他线程观察，所有操作都是无序的。无序指的是指令重排序和工作内存和主内存的同步延迟。volatile和synchronized关键字可以保证线程之间操作的有序性。

### 先行发生原则
为了更有效率解决有序性的问题，Java语言提供了一个`先行发生`的原则。先行发生指的是Java内存模型中定义的两项操作之间的偏序 关系，如果操作A先行发生于操作B，那么在多线程环境中，线程2的操作B发生之前，线程1操作A产生的影响可以被操作B观察到。
Java内存模型定义了一些先行发生关系，可以在无序任何同步器协助下存在，如果两个操作的关系不在此列，则它们没有顺序性保证，虚拟机可以对它们随意重排序。
* 程序次序规则：在一个线程中，按照程序代码顺序，书写在前面的操作先行发生于书写在后面的操作。
* 管程锁定规则：一个unlock操作先行发生与后面对同一个锁的lock操作。
* volatile变量规则：volatile变量的写操作先行发生与后面对这个变量的读操作。
* 线程启动规则：Thread对象的start()方法先行发生于线程的每一个动作。
* 线程终止规则：线程所有操作都先行发生于此线程的终止检测。
* 线程中断规则：对线程interrupt()方法的调用先行发生于被终端线程的代码检测到中断事件的发生。
* 对象终结规则：一个对象的初始化完成先行发生于finalize()方法开始。
* 传递性：操作A先行发生于操作B，操作B先行发生于操作C，那么操作A先行发生于操作C。

###  Java与线程
线程的实现有三种方式：
1. 使用内核线程实现
内核线程就是直接由操作系统内核支持的线程，这种线程由内核来完成线程切换，内核通过操作调度器来对线程进行调度，并负责把线程的任务映射到各个处理器上。
程序一般不会直接使用内核线程，而是使用内核线程的高级接口——轻量级进程，轻量级进程就是通常意义的线程，每个轻量级线程都有一个内核线程支持，轻量级线程和内核线程的对应关系是一比一的线程模型。
轻量级进程的优点是每个轻量级进程都是一个独立的调度单元，单个轻量级进程的阻塞不会影响这个进程的工作。缺点是基于内核线程实现，所以各种线程操作都需要系统调用，在用户态和内核态来回切换，代价较高。而且每个轻量级进程都需要一个内核线程的支持，所以需要消耗一定的内核空间，一个系统支持的轻量级进程的数量是有限的。
2. 使用用户线程实现
狭义的用户线程指的是完全建立在用户空间的线程库，系统内核不能感知到线程的存在，用户线程的建立、同步、销毁和调度完全在用户态实现，不需要内核的帮助。所以操作是非常快速而且低消耗的，也可以支持更大规模的线程数量。部分高性能数据库的多线程就是由用户线程实现的。劣势在于没有系统内核的支持，所有线程操作都需要用户程序处理，包括线程创建切换调度等。
3. 使用用户线程加轻量级进程混合实现
这种模式下，用户线程还是建立在用户空间，因此用户线程的操作还是高效率的，并且支持大规模的用户线程并发。操作系统提供支持的轻量级进程作为用户线程和内核的桥梁，这样可以使用内核提供的线程调度和处理器映射。

目前的JDK版本，Java虚拟机线程的实现取决于操作系统的线程模型。

#### Java线程调度
线程调度指的是系统为线程分配处理器使用权的过程，主要调度方式分为两种：
* 协同式线程调度，线程的执行时间由线程本身控制，线程执行完毕后，要主动通知系统切换到另一个线程。这种方式优点是实现简单，没有县线程同步的问题，缺点是线程执行时间不确定，可能出现长时间阻塞在一个线程处的情况。
* 抢占式线程调度，由系统分配线程的执行时间，线程的切换由系统决定。Java使用的线程调度方式就是抢占式调度。

尽管线程调度由系统自动完成，但是可以通过设置线程优先级来建议系统为某些线程多分配一点执行时间。这种方式并不可靠，线程调度最终还是取决于操作系统。

线程的状态转换关系如下：

![java-javascript](/img/in-post/java-virtual-machine/thread_status.jpg)
<small class="img-hint">线程状态转换关系</small>
