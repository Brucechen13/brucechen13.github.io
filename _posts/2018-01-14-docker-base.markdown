---
layout:     post
title:      "Docker相关笔记"
subtitle:   ""
date:       2018-10-17
author:     "brucechen"
header-img: "img/post-bg-java.jpg"
published: true
tags:
    - Docker
    - 读书笔记
---

### 从物理机到虚拟机到容器

物理机就是真实的机器，带有真实物理组件的系统。

虚拟机则是采用虚拟化技术抽象出来的系统，虚拟化系统的实现通常是在操作系统和硬件之间加入一个虚拟机监控程序，称为Hypervisor。由Hypervisor主要负责各个操作系统之间的硬件资源协调。虚拟机监控程序是一种特殊操作系统，直接在裸机上运行（针对完全虚拟化技术）。虚拟机监控程序创建一个底层硬件平台抽象，一个或多个虚拟机（VM）共享这个底层硬件平台。在这种环境中，VM只是操作系统及其应用程序的容器，

一般来说，虚拟机都会有自己的kernel，自己的虚拟硬件，这样虚拟机启动的时候需要先做开机自检，启动kernel，启动用户进程等一系列行为，虽然现在电脑运行速度挺快，但是这一系列检查做下来，也要几十秒，也就是虚拟机需要几十秒来启动。
重新来理解虚拟机的概念，计算机科学家发现其实我们创建虚拟机也不一定需要模拟硬件的输入和输出，假如宿主机和虚拟机他们的kernel是一致的，就不用做硬件输入输出的搬运工了，只需要做kernel输入输出的搬运工即可，为了有别于硬件层面的虚拟机，这种虚拟机被命名为 操作系统层虚拟化：Operating-system-level virtualization也被叫做容器。

传统虚拟机技术是虚拟出一套硬件后，在其上运行一个完整操作系统，在该系统上再运行所需应用进程；而容器内的应用进程直接运行于宿主的内核，容器内没有自己的内核，而且也没有进行硬件虚拟。因此容器要比传统虚拟机更为轻便。

容器与虚拟机的对比如下图：

[!对比](http://img3.tbcdn.cn/L1/461/1/75b502be6bc8585968f9895bf086cf7b7cdab9c8)


### Docker介绍

Docker就是Google实现虚拟化的一种轻量级替代技术，自从出现以来就广受好评，现在基本一提起容器技术大家就会首先想到Docker。

Docker就是使用Linux Kernel的Namespace 和 Cgroups实现的一种容器技术，下面对Docker几个主要组件进行详细说明。

#### Namespaces

在日常使用 Linux 或者 macOS 时，我们并没有运行多个完全分离的服务器的需要，但是如果我们在服务器上启动了多个服务，这些服务其实会相互影响的，每一个服务都能看到其他服务的进程，也可以访问宿主机器上的任意文件，这是很多时候我们都不愿意看到的，我们更希望运行在同一台机器上的不同服务能做到完全隔离，就像运行在多台不同的机器上一样。

Docker 通过 Linux 的 Namespaces 对不同的容器实现了隔离，为我们提供的用于分离进程树、网络接口、挂载点以及进程间通信等资源的方法。

#### 进程

Docker容器中的进程与宿主kernel中的进程隔离。

#### 网络

Docker 为我们提供了四种不同的网络模式，Host、Container、None 和 Bridge 模式。

#### CGroups

通过 Linux 的命名空间为新创建的进程隔离了文件系统、网络并与宿主机器之间的进程相互隔离，但是命名空间并不能够为我们提供物理资源上的隔离，比如 CPU 或者内存，如果在同一台机器上运行了多个对彼此以及宿主机器一无所知的『容器』，这些容器却共同占用了宿主机器的物理资源。

如果其中的某一个容器正在执行 CPU 密集型的任务，那么就会影响其他容器中任务的性能与执行效率，导致多个容器相互影响并且抢占资源。如何对多个容器的资源使用进行限制就成了解决进程虚拟资源隔离之后的主要问题，而 Control Groups（简称 CGroups）就是能够隔离宿主机器上的物理资源，例如 CPU、内存、磁盘 I/O 和网络带宽。

Linux 的 CGroup 能够为一组进程分配资源，也就是我们在上面提到的 CPU、内存、网络带宽等资源。

#### 镜像

Docker 中的每一个镜像都是由一系列只读的层组成的，Dockerfile 中的每一个命令都会在已有的只读层上创建一个新的层。

当镜像被 docker run 命令创建时就会在镜像的最上层添加一个可写的层，也就是容器层，所有对于运行时容器的修改其实都是对这个容器读写层的修改。

容器和镜像的区别就在于，所有的镜像都是只读的，而每一个容器其实等于镜像加上一个可读写的层，也就是同一个镜像可以对应多个容器。

### 为什么使用Docker

docker 的好处

简单说: 标准化交付，微服务编排，提升资源利用率。

1. 校准化交付
    
    docker 将应用及其所有依赖打包到镜像内, 包括二进制文件(包括底层基础库), 静态配置文件, 环境变量等。剥离了应用对操作系统和环境的依赖， 松耦合 。只需要拉取镜像, 启动容器即可完成应用部署, 方便。毫秒级创建销毁容器，从而可以实现 快速部署、快速迁移、快速扩容缩容，一键快速回滚 (只依赖应用启动时间)。docker镜像制定了应用交付标准, 开发人员对应用及其运行环境完全可控，并有效避免各种环境问题踩坑。

2. 微服务编排

    单机部署多应用时，应用之间完全解耦，可以任意部署编排, 完美支持微服务编排的需求。多个 C 应用混布时, docker 化实现 C 依赖隔离, 避免依赖冲突。

3. 提升资源利用率

    docker是轻量级的解决方案, 不做虚拟化, 不运行多余的 kernel 和 init 进程, 能有效提升资源利用率。

Docker目前最广泛的使用场景如下：

1. 容器化传统应用 容器不仅能提高现有应用的安全性和可移植性，还能节约成本。
2. 持续集成和持续部署 通过 Docker 加速应用管道自动化和应用部署，交付速度提高至少 13 倍。
3. 微服务 加速应用架构现代化进程。
4. IT 基础设施优化 充分利用基础设施，节省资金。
