---
layout:     post
title:      "深入理解JAVA虚拟机学习笔记"
subtitle:   "第八章 虚拟机字节码执行引擎"
date:       2016-01-24
author:     "brucechen"
header-img: "img/post-bg-java.jpg"
tags:
    - Java
    - 读书笔记
---

### 虚拟机执行引擎
虚拟机的执行引擎不同于物理机的执行引擎，不需要受限于处理器、硬件、指令集和操作系统，可以自行制定指令集和执行引擎的结构体系，并能够执行那些不被硬件直接支持的指令集格式。
运行时栈帧，用于支持虚拟机进行方法调用和方法执行的数据结构，是运行时数据区中虚拟机栈的栈元素。栈帧存储了方法的局部数量表、操作数栈、动态连接和方法返回地址和一些额外的附加信息，栈帧需要多大的局部变量表和多深的操作数栈在方法编译时就可以确定，并写在方法表的Code属性中，因此，栈帧需要分配多少内存与程序运行期变量数据没有关系，只取决于具体的虚拟机实现。
* 局部变量表
一组变量值存储空间，用于存放方法参数和方法内部定义的局部变量。方法表中Code属性的max_locals数据项确定了该方法所需分配的局部变量表最大容量。
局部变量表的容量以变量槽(slot)为最小单位。
* 操作数栈
一个后入先出栈，最大深度写到Code属性的max_stacks数据项。
* 动态连接
每个栈帧都包括一个指向运行时常量池中该栈帧所属方法的引用，持有这个引用是为了支持方法调用过程中的动态连接。
* 方法返回地址
当一个方法开始执行后，只有两种方式可以退出这个方法，一种是执行引擎遇到任意一个方法返回的字节码指令，这个时候返回到上层的方法调用者，这种退出方式称为正常完成入口。
另一种是方法执行过程中遇到了异常，并且这个异常没有在方法体内得到处理，导致方法退出，这种方式称为异常完成出口，异常完成出口不会产生任何返回值。

### 方法调用
方法调用不等于方法执行，方法调用阶段的唯一任务是确定被调用方法的版本，即需要调用哪一个方法。所有方法调用的目标方法在Class文件中都是一个常量池的符号引用，类加载的解析阶段会将一部分符号引用转换为直接引用，这种解析成立的前提是方法在程序运行前就有一个可确定的调用版本，并且在运行期不可改变。
符合这种编译器可知、运行期不可变要求的方法，主要包括静态方法、私有方法、实例构造器、父类方法，前者与类型直接关联，后者外部不可访问。因此都无法通过继承或别的方法重写其他版本。
方法重载通过参数的静态类型而不是实际类型来决定使用哪个重载版本，所以编译器就可以确定调用方法的版本，这种分派动作称为 **静态分派** 。
重载方法的选取有时候并不是唯一的，一般会按照`char->int->long->float->double`的顺序转型进行匹配，然后是对象、接口、可见变长参数。
重写方法则无法在编译时确定，分派调用的方法需要通过invokevirtual指令执行，解析过程大致分为以下几个步骤：
1. 找到操作数栈顶的第一个元素所指向的对象实际类型，记作C
2. 如果在类型C中找到与常量中描述符和简单名称都相符的方法，则进行访问权限校验，通过则返回这个方法的直接引用，否则返回`java.lang.IllegalAccessError`异常
3. 如果找不到方法，则按照继承关系从下往上依次对C的各个父类进行2中的搜索
4. 如果始终没有找到，则抛出`java.lang.AbstractMethodError`异常。
运行期进行分派的过程叫做 **动态分派。**
方法的接收者和方法参数称为方法的 **宗量** ，根据分派基于多少宗量，将分派分为单分派和多分派，静态分派需要依赖于方法的接收者和参数类型，所以属于JAVA语言的静态分派属于多分派。动态分派时，因为已经确定了方法的参数类型，所以只需要关系方法的接收者的类型，所以JAVA语言的动态分派属于单分派类型。
动态分派时非常频繁的动作，所以出于性能的考虑，一般不会逐一搜索类的方法元数据，常用的手段是在类的方法区建立一个虚方法表，使用虚方法表索引来代替元数据查找。虚方法表结构示例如下：

![java-javascript](/img/in-post/java-virtual-machine/virtual-method-table.png)
<small class="img-hint">虚方法表</small>

### 动态类型语言支持
动态类型语言的关键特征在于类型检查的主体过程发生在运行期，JDK1.7提供了`java.lang.invoke`包实现动态语言支持。