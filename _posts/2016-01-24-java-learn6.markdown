---
layout:     post
title:      "深入理解JAVA虚拟机学习笔记"
subtitle:   "第七章 虚拟机类加载机制"
date:       2016-01-24
author:     "brucechen"
header-img: "img/post-bg-java.jpg"
tags:
    - Java
    - 读书笔记
---

### 类的加载和卸载
Class文件需要加载到虚拟机中才可以运行和使用，虚拟机把描述类的数据从Class文件加载到内存，并对数据进行校验、转换解析和初始化，最终形成可以被虚拟机直接使用的JAVA类型，这就是虚拟机类加载机制。
JAVA语言的类型加载、连接和初始化过程是在程序运行期间完成的，这样虽然回味类加载增加一些性能开销、但是可以为JAVA应用程序提供高度的灵活性，JAVA天生可以动态扩展的语言特性就是利用运行期动态加载和动态连接这个特点实现的。
类的加载和卸载包括以下七个阶段：

![java-javascript](/img/in-post/java-virtual-machine/class-load.png)
<small class="img-hint">类的加载和卸载</small>

加载、验证、准备、初始化和卸载的顺序是确定的，解析阶段则不一定，可能发生在初始化阶段之后，这是为了支持JAVA语言的运行时绑定。

##### 加载

JAVA虚拟机规范对于类何时加载并没有强制规范，但是虚拟机规范定义了五种必须立即对类进行初始化的情况，加载、验证、准备自然必须在初始化前进行：

+ 遇到new、getstatic、putstatic、invokestatic这四条字节码指令时，如果没有对类进行初始化过，则必须先触发初始化。
*  使用java.lang.reflect包的方法对类进行反射调用的时候，如果类没有进行初始化，必须先触发其初始化
* 当初始化一个类的时候，如果发现其父类还没有进行初始化，必须先触发其父类的初始化
* 虚拟机启动时，用户需要指定一个要执行的主类，虚拟机先初始化这个主类
*  当使用JDK1,7的动态语言支持时，如果一个java.lang.invoke.MethodHandle实例最后的解析结果时REF_getStatic、REF_putStatic、REF_invokeStatic的方法句柄，并且这个方法句柄对应的类还没有初始化，需要先触发其初始化。
加载阶段，虚拟机需要完成以下3件事情：
1. 通过类的全限定名获取定义此类的二进制字节流
2. 将这个字节流所代表的静态存储结构转换为方法区运行时数据结构
3. 内存中生成一个代表这个类的java.lang.Class对象，作为方法区数据访问入口

##### 验证

验证的目的是确保Class文件的字节流符合虚拟机要求，并且不会危害虚拟机自身的安全。因为Class文件并不一定是由JAVA源码编译而来，有可能被他人篡改，所以为了确保不会因为载入有害的字节流而导致系统崩溃，验证是虚拟机自我保护的重要工作。
验证大致分为四个阶段的校验工作：
1. 文件格式验证
验证字节流是否符合Class文件格式的规范，并且能被当前版本的虚拟机支持。
2. 元数据验证
对字节码描述信息进行语义分析，保证描述的信息符合JAVA语言规范的要求，例如这个类是否有父类、是否继承了不允许继承的类、是否出现了不符合规则的方法重载等。
3. 字节码验证
验证过程最复杂的阶段，通过数据流和控制流分析，确保程序语义是合法的、符合逻辑的。避免操作数栈的数据类型与指令代码序列不匹配，如使用long类型加载本地int类型的数据、跳转指令跳转到方法体之外的字节码指令、方法体之间转换无效等。
为了避免过多的时间消耗在字节码验证阶段，JDK1.6之后JAVAC编译器和java虚拟机进行了一项优化，为方法体的Code属性增加了一项名为StackMapTable的属性，描述了方法体中所有基本块开始时本地变量表和操作数栈应有状态，字节码验证阶段，只需要检查这些记录是否合法即可。
4. 符号引用验证
将虚拟机符号引用转换为直接引用，这个转化动作发生在连接的解析阶段。
虚拟机验证并不是必须的过程，程序运行的所有代码都是可信任的，可以使用-Xverify:none关闭大部分类验证措施，缩短加载时间。

##### 准备

准备阶段会为类变量分配内存并设置类变量初始值，初始值通常为数据类型的零值。数据类型的零值关系如下：

![java-javascript](/img/in-post/java-virtual-machine/datatype.png)
<small class="img-hint">数据类型初始化</small>

如果类字段的字段属性表中存在`Constant-Value`属性，则初始化时会初始化为常量的值。

##### 解析

解析就是将常量池内的符号引用替换为直接引用的过程，符号引用以一组符号来描述所引用的目标，字面量定义在class文件的常量池中，直接引用可以是直接指向目标的指针、相对偏移量或一个间接定位到目标的句柄。
解析可以在类被加载器加载时进行或对常量池符号引用使用前进行，解析前需要进行符号引用验证。

##### 初始化

初始化阶段才开始执行类中定义的Java代码，也就是类构造器`clinit`方法。
`clinit`方法是由编译器自动收集类中所有类变量的赋值动作和静态语句块中的语句合并产生的，方法内的语句顺序与源文件中出现顺序一致，需要注意的是，静态语句块中只能访问定义在语句块之前的变量，定义在之后的变量，可以被赋值，不能被访问。 
`clinit`方法与类构造函数（或者说实例构造器`init`）方法不同，不需要显式调用父类构造器，虚拟机会保证子类的`clinit`方法执行前，父类的`clinit`方法已经执行完毕。
接口中不能使用静态语句块，但仍有类变量的初始化，所以依然会生成`clinit`方法，当接口`clinit`方法执行时不需要先执行父接口的`clinit`方法，只有当父接口定义的变量使用时，父接口才会初始化。接口的实现类初始化也一样不会执行接口的初始化。

### 类加载器
类加载时，通过类的全限定名获取描述此类的二进制字节流的过程通过类加载器来实现。任意一个类都是由加载它的加载器和这个类本身来确定唯一性。
类加载器大致可以分为三类：
* 启动类加载器，加载`<JAVA_HOME>\lib`目录下或者被-Xbootclasspath参数指定的目录中，并且可以被虚拟机识别的类库加载到虚拟机内存中。
* 扩展类加载器，加载`<JAVA_HOME>\lib\ext`目录下，或者被java.ext.dirs系统变量指定的路径下所有类库。
* 系统类加载器，加载用户类路径上指定的类库，程序默认的类加载器。
类加载器通过 **双亲委派模型** 来进行类加载，除了顶层的启动类加载器，其余加载器都应该有一个父类加载器，这里的父子关系通过组合来实现，当一个类加载器需要加载一个类时，首先会将请求委派到父类加载器，依次传递，最终传递到顶层的启动类加载器，只有父加载器在搜索范围找不到指定类时，子类才会尝试自己去加载。
有时为了满足需求，需要修改类加载的模式，比如在OSGI中，为了实现模块的热部署，实现了自定义的类加载机制，每个程序模块都有一个自己的类加载器，当需要更换模块时，将模块连同类加载器一起换掉实现代码热替换。OSGI的类加载机制如下：
1. 将以java.*开头的类委派给父类加载器加载。
2. 否则，将委派列表名单内的类委派给父类加载器加载。
3. 否则，将Import列表中的类委派给Export这个类的Bundle的类加载器加载。
4. 否则，查找当前Bundle的ClassPath，使用自己的类加载器加载。
5. 否则，查找类是否在自己的Fragment Bundle中，如果在，则委派给Fragment Bundle的类加载器加载。
6. 否则，查找Dynamic Import列表的Bundle，委派给对应Bundle的类加载器加载。
7. 否则，类查找失败。
