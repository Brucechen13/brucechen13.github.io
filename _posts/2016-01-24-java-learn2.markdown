---
layout:     post
title:      "深入理解JAVA虚拟机学习笔记"
subtitle:   "第三章 垃圾回收器"
date:       2016-01-24
author:     "brucechen"
header-img: "img/post-bg-java.jpg"
tags:
    - Java
    - 读书笔记
---

### 垃圾回收算法
* 引用计数算法
给对象添加一个引用计数器，当有一个地方引用它时，计数器加一；当引用失效时，计数器减一。计数器为零的对象就是可以被回收的垃圾对象。
优点：实现简单，效率较高
缺点：无法解决循环引用的问题，即A引用B，B引用A，除此之外再无其他对A、B的引用，虽然A、B不再被访问，仍然无法回收A，B。
* 可达性分析算法
通过一系列`GC Roots`的对象作为起始点，向下搜索，搜索走过的路径就是引用链，当一个对象到GC Roots没有任何引用链相连，该对象就是不可达对象。
回收机并不会立即回收不可达对象，而是首先被第一次标记并经过一次筛选，筛选的条件是此对象是否有必要执行finalize()方法。当对象没有覆盖该方法，或者该方法已经执行过，则视为筛选通过。否则，该对象会被添加到一个叫做`F-Queue`的队列中，并在稍候由一个虚拟机自动建立、低优先级的Finalizer线程执行，即去触发finalize()方法，但不承诺会等到方法结束，因为如果该方法执行缓慢，或者发生了死循环，会导致队列其他对象陷入长时间等待，甚至导致整个垃圾回收系统崩溃。finalize()方法是对象不被回收的最后一次机会。随后GC对F-Queue中对象进行第二次标记，如果对象在finalize()方法中重新和引用链中任何一个对象建立关联，则在第二次标记时将它移除，否则，对其进行回收。
可以作为GC Roots的对象包括：
 + 虚拟机栈（帧栈中本地变量表）中引用的对象
 + 方法区类静态属性引用的对象
 + 方法区常量引用的对象
 + 本地方法栈中JNI引用的对象
* 标记清除算法
首先标记出所有需要回收的对象，在标记完成后统一进行回收。
缺点：效率不高，产生内存碎片。
* 复制算法
将可用内存分为大小相等的两块，每次只是用其中一块，当一块内存用光了，就将还存活的对象复制到另一块上，对这一块内存全部清理。
优点：实现简单，运行高效
缺点：内存使用率降低一半
现代商业虚拟机都采用这种算法来回收新生代，因为新生代存活率极低，所以可以把内存分为一块较大的Eden空间和两块较小的Survivor空间，每次使用Eden和其中一块Survivor，回收时，将两块内存的存货对象都复制到另一块Survivor空间，清除这两块内存。Hotspot虚拟机默认Eden和Survivor的比例是8：1。如果遇到Survivor空间不足的时候，需要依赖其他内存（老生代）来进行分配担保。
* 标记整理算法
如果对象存活率较大时，复制收集算法就不再使用了，标记整理算法是一种适用于老年代的收集算法。标记过程与标记清除一样，标记后将存货对象向一端移动，清除掉端边界以外的内存。
* 分代收集算法
当前商业虚拟机的垃圾回收器都采用分代收集算法，根据对象存活周期将内存划分成几块。一般JAVA堆会被分为新生代和老生代，根据特点采用适当的收集算法。

### 枚举根节点
可达性分析中需要从`GC Roots`节点查找引用链，如果逐一检查引用，必然十分耗时，而且分析还必须保证在一个能确保一致性的快照中进行，不可以出现分析过程引用关系还在发生变化的情况，所以GC时必需停顿所有JAVA执行线程（`Stop The World`）。
目前主流JAVA虚拟机使用 **准确式GC** ，当执行系统停顿时，并不需要检查所有引用位置，虚拟机可以直接得知哪些地方存放对象引用。在Hotspot实现中，通过`OopMap`的数据结构来实现目的。类加载的时候，Hotspot就将对象内什么偏移量上是什么类型的数据计算出来，JIT编译过程中也会在特定的位置记录下栈和寄存器哪些位置是引用，这样GC扫描时就可以直接得知这些信息了。
`OopMap`并不会为每一条指令生产对应的OopMap，那样会需要大量的额外空间，也没有必要，因为记录OopMpa只是为了GC，所以OopMap只会在特定的位置记录，这些位置称为安全点（`SafePoint`），即程序执行时并非在所有地方都能停顿进行GC，只有达到安全点才会暂停。安全点的选定基本是以程序是否具有让程序 长时间执行的特征作为标准，长时间执行最明显的特征就是指令序列复用，例如方法调用、循环跳转、异常跳转等，具有这些功能的指令才会产生SafePoint。
当程序到达SafePoint，为了在GC时让所有的线程都执行到最近的安全点再停顿下来，可以采用抢先式中断和主动式中断。抢先式中断就是在GC发生时，首先把所有线程中断，如果发现线程中断的地方不在安全点，就恢复线程，执行到安全点的代码处。主动式中断是当GC需要中断线程时，仅仅设置一个标记，每个线程执行时主动去轮询这个标记，如果发现标记为真就自己中断挂起。轮询标记的的地方和安全点时重合的，另外还有创建对象分配内存的时候，即只会在安全点的代码处和创建对象需要内存时才会进行轮询标记。
几乎所有的虚拟机采用的都是主动式中断的方法，因为这样效率更高。
安全点保证了线程执行时可以进行中断，可是当线程处于Sleep状态或Blocked状态，这时线程就无法进入安全点进行主动式中断，所以还需要安全区域来解决线程没有分配CPU时间的情况。 安全区域是指一段代码片段中，引用关系不会发生变化，所以在这个区域中的任何地方开始GC都是安全的。当线程执行到安全区域的代码时，首先标示自己已经进入安全区域，这样当JVM发起GC，就不用管标示自己为安全区域状态的线程了。当线程要离开安全区域时，需要检查 系统是否完成了根节点枚举（或者整个GC过程），如果完成了，则继续执行，否则，必须等待到可以安全离开安全区域的信号为止。

### 垃圾收集器
垃圾收集器就是垃圾回收的具体实现，Java虚拟机规范对垃圾收集器如何实现并没有规定，因此存在不同的垃圾收集器可以应用在不同的场景中。 HotSpot虚拟机提供的的垃圾回收器如下图，如果两个收集器存在连线，说明可以搭配使用。

![java-javascript](/img/in-post/java-virtual-machine/garbage-generation.png)
<small class="img-hint">JVM收集器种类</small>

* Serial收集器
最基本、历史最悠久的收集器，JDK1.3之前曾经是新生代收集器的唯一选择。这是一个单线程的收集器，不仅意味着只能使用一条收集线程，而且收集也必须暂停其他所有工作线程。运行在Client模式下默认的新生代收集器。
优点：简单、高效，单CPU环境下节省线程交互的开销。
* ParNew收集器
Serial收集器的多线程版本，除了使用多线程进行垃圾回收，其他收集策略和Serial收集器完全一样。
* Paraller Scavenge收集器
新生代收集器，使用复制算法的并行多线程收集器，可以提供一个吞吐量可控制的收集器。吞吐量就是CPU用于运行用户代码的时间与CPU总消耗时间的比值。高吞吐量可以高效率运用CPU时间，尽快完成程序运算任务，只要适用于后台运算而不需要太多交互的任务。提供控制最大垃圾收集停顿时间（MaxGCPauseMills）和设置吞吐量大小(GCTimeRatio)的参数。设置过小的最大垃圾收集停顿时间会导致GC的频繁执行，进而使吞吐量下降。GCTimeRatio介于0到100，就也就是垃圾收集时间占总时间的比率。 除此之外，还提供了参数（UseAdaptiveSizePolicy），可以使用GC自适应的调节策略，自动配置新生代大小、Eden与Survivor比例等虚拟机细节。
* Serial Old收集器
Serial收集器的老年代版本，单线程收集器，采用标记整理算法。
* Parallel Old收集器
Parallel Scavenge收集器的老年代版本，采用多线程和标记整理算法，用于配合Parallel Scavenge实现高吞吐量。
* CMS收集器
CMS收集器是一种以获取最短回收时间为目标的老年代收集器，可以搭配ParNew收集器使用，主要用于互联网站、B/S系统的服务端等重视响应速度的地方。CMS收集器基于标记清除算法实现，主要分为四个步骤：
 + 初始标记
仅仅标记GC Roots能直接关联到的对象，速度很快，需要停顿JVM
 + 并发标记
找到GC Roots的关联链，耗时较长，不需要停顿
 + 重新标记
修正并发标记期间引用标记发生变动的那一部分对象的标记记录，需要停顿
 + 并发清除
清除引用链索引不到的对象，不需要停顿
优点：并发收集，低停顿
缺点：对CPU资源敏感，并发时需要占用一部分线程，默认线程数（CPU数量+3）/4。无法处理浮动垃圾，由于并发清理时用户线程还在运行，运行时产生的垃圾只能下次GC时回收，这部分垃圾就是浮动垃圾。采用标记清除算法，会产生空间碎片。
* G1收集器
面向服务器应用的垃圾收集器，被设计用来替代CMS收集器。G1收集器可以充分利用多CPU、多核环境下的硬件优势，使用多个CPU来缩短Stop-The-World停顿时间，部分其他收集器原本需要停顿JAVA线程执行的GC动作，G1收集器可以通过并发的方式让Java程序继续执行。G1收集器并没采用标记清理算法，而是采用类似复制算法，所以不会产生内存空间碎片。G1收集器除了追求GC的低停顿外，还能建立可预测的停顿时间模型，能让使用者明确在一个长度为M毫秒的时间片段内，消耗在垃圾回收的时间不超过N毫秒。
G1收集器和其他收集器不同，收集范围并不是整个新生代或老年代，而是将JAVA堆划分为多个大小相等的独立区域（Region），虽然还存在新生代和老年代的划分，单不再是物理隔离，而是Region的集合。
G1收集器之所以可以建立可预测的停顿时间模型，也正是因为可以避免在整个堆中进行垃圾回收，而是跟踪Region中垃圾堆积的价值大小（回收获取的空间大小和回收所需时间），后台维护一个优先列表，每次根据允许的收集时间，优先回收价值最大的Region，保证了有闲时间的尽可能高收集效率。
划分Region进行回收的难点在于如何确定Region中对象的可达性，G1收集器中，虚拟机使用Remembered Set来避免全堆扫描。每个Region都有对应的Remembered Set，虚拟机发现程序对引用类型的数据进行写操作时，会产生Write Barrier暂时中断写操作，检查引用的对象是否处在不同的Region中，如果是，则通过CardTable将相关引用信息记录到被引用对象所属的Region的Remembered Set中，内存回收时，在根节点的枚举范围加入Remembered Set保证全堆回收不会遗漏。
G1收集器的运作大致可划分为以下几个步骤：
 + 初始标记
 + 并发标记
 + 最终标记
 + 筛选标记



方法区回收
JAVA虚拟机规范并不要求虚拟机在方法区实现垃圾回收，因为方法区回收的效率较低。永久代的垃圾回收主要回收两部分：废弃常量和无用的类。回收废弃常量和回收JAVA堆中对象非常相似，如果当前系统没有任何引用指向该常量，或者指向该常量的字面量，如果必要的话，就会在垃圾回收时被清理出常量池（？？？如何寻找该常量，何时必要，怎么清理，是不是也会经过两次标记）。判定一个类是否废弃则十分苛刻，需要满足以下三个条件：1.该类所有实例已经被回收。2.加载该类的ClassLoader已经被回收。3.该类的Class对象没有被引用，即在任何地方无法通过反射访问该方法。满足条件的类仅仅是可以被回收，虚拟机提供了-Xnoclasssgc参数来控制是否对废弃类进行回收。在大量使用反射、动态代理、CGLib等ByteCode框架、动态生成JSP以及OSGi这类频繁自定义ClassLoader的场景都需要虚拟机具备类卸载的功能，以保证永久代不会溢出。


对象引用分类
JDK1.2以后，java对引用的概念进行了扩充，将引用分为强引用，软引用，弱引用和虚引用四种，这四种引用强度分别减弱。
强引用就是通过意义上的引用，通过new创建的对象指向的就是强引用。只要强引用还存在，垃圾回收期就永远不会回收被引用的对象。
软引用是用来描述一些有用但并非必需的对象，通过SOftReference类实现。当系统将要发生内存溢出异常时，就会把这些对象列入回收范围之中进行第二次回收，如果这次回收内存依然不足，才会抛出内存溢出异常。
弱引也用来描述非必需的对象，但强度比软引用更弱一点，通过WeakReferencce类实现弱引用。被弱引用关联的对象只会生存到下一次垃圾回收发生之前，当垃圾回收器工作时，不管内存是否足够。都会回收被弱引用关联的对象。
虚引用也被成为幽灵引用，最弱的一种引用关系，对生存时间完全没有影响，无法通过虚引用取得一个对象实例。虚引用关联的唯一目的是在这个对象被回收器回收时收到一个系统通知。通过PhantonmReference类实现。
