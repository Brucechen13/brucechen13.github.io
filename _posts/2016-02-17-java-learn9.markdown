---
layout:     post
title:      "深入理解JAVA虚拟机学习笔记"
subtitle:   "第10章 编译期优化"
date:       2016-02-16
author:     "brucechen"
header-img: "img/post-bg-java.jpg"
published: false
tags:
    - Java
    - 读书笔记
---

### 编译过程
Java的编译过程大致可分为三类：

* 前端编译器：Sun的Javac、Eclipse JDT中的增量式编译器（ECJ）
常见的Java编译器，将把`*.java`文件转变成`*.class`文件的过程。
* JIT编译器：HotSpot VM的C1、C2编译器
即时编译器，运行时将字节码转变成机器码的过程
* AOT编译器：GNU Compiler for the Java（GCJ）、Excelsior JET
静态提前编译器，直接把*.java文件编译成本地机器代码的过程。

前端编译器是最常用的编译器，它的编译过程可分为三个过程。

![java-javascript](/img/in-post/java-virtual-machine/javac-compiler.jpg)
<small class="img-hint">Javac编译过程</small>

#### Javac编译过程

* 解析与填充符号表
 1. 解析步骤包括了经典程序编译原理中的词法分析和语法分析两个过程。词法分析将源代码的字符流转换为`Token`集合，语法分析根据`Token`序列构造抽象语法树。抽象语法树（`Abstract Syntax Tree,AST`）是一种用来描述程序代码语法结构的树形表示方式，语法树的每一个节点都代表着程序代码中的一个语法结构，例如包、类型、修饰符、运算符、接口、返回值甚至代码注释等都可以是一个语法结构。
 2. 符号表（`Symbol Table`）是一组符号地址和符号信息构成的表格。符号表中所登记的信息在编译的不同阶段都要用到。在语义分析中，符号表所登记的内容将用于语义检查（如检查一个名字的使用和原先的说明是否一致）和产生中间代码。在目标代码生成阶段，当对符号名进行地址分配时，符号表是地址分配的依据。
* 注解处理器
JDK 1.5之后，Java语言提供了对注解（`Annotation`）的支持，这些注解与普通的Java代码一样，是在运行期间发挥作用的。
在JDK 1.6中实现了`JSR-269`规范，提供了一组插入式注解处理器的标准API在编译期间对注解进行处理，可以把这种处理看做是一组编译器的插件，在这些插件里面，可以读取、修改、添加抽象语法树中的任意元素。如果这些插件在处理注解期间对语法树进行了修改，编译器将回到解析及填充符号表的过程重新处理，直到所有插入式注解处理器都没有再对语法树进行修改为止。
* 语义分析与字节码生成
语法分析后的抽象语法树表示一个结构正确的源程序抽象，但不能保证代码时符合逻辑的。而语义分析的主要任务是对结构上正确的源程序进行上下文有关性质的审查，包括标注检查、数据与控制流分析。
 1. 标注检查
 标注检查步骤检查的内容包括诸如变量使用前是否已被声明、变量与赋值之间的数据类型是否能够匹配等。在标注检查步骤中，还有一个重要的动作称为常量折叠，如果一个变量在编译器就可以确定为一个字面量，那么这个变量就会直接折叠位这个字面量。
 2. 数据集控制流分析
 检查出诸如程序局部变量在使用前是否有赋值、方法的每条路径是否都有返回值、是否所有的受查异常都被正确处理了等问题。编译时期的数据及控制流分析与类加载时的数据及控制流分析的目的基本上是一致的，但校验范围有所区别，有一些校验项只在编译器或运行期进行。如下列代码：
 
 ```
 public void foo(final int arg) {    
	final int var = 0;    
	// do something
 }
 // 方法二没有final修饰
 public void foo(int arg) {    
	int var = 0;    
	// do something
 }
 ```
 
 由于局部变量与字段（实例变量、类变量）是有区别的，它在常量池中没有CONSTANT_Fieldref_info的符号引用，自然就没有访问标志（Access_Flags）的信息，所以局部变量的final修饰在运行期没有意义，局部final变量的不变性仅有编译器在编译阶段保证。
 3. 解语法糖
 语法糖指的是计算机语言中添加的某种语法，这种语法对语言的功能并没有影响，但是更方便程序员使用。
  + 泛型擦除
  Java中的泛型不同于常见的泛型概念，它只在程序源码中存在，在编译后的字节码文件中，就已经替换为原来的原生类型（`Raw Type`，也称为裸类型）了，并且在相应的地方插入了强制转型代码，因此，对于运行期的Java语言来说，ArrayList<int>与ArrayList<String>就是同一个类ArrayList，所以泛型技术实际上是Java语言的一颗语法糖，Java语言中的泛型实现方法称为类型擦除，基于这种方法实现的泛型称为伪泛型。
  + 自动装箱、拆箱、遍历循环、变长参数
  自动装箱、拆箱在编译之后被转化成了对应的包装和还原方法，例如Integer.valueOf()与Integer.intValue()方法，而遍历循环则把代码还原成了迭代器的实现，这也是为何遍历循环需要被遍历的类实现Iterable接口的原因。变长参数在调用的时候变成了一个数组类型的参数，在变长参数出现之前，程序员就是使用数组来完成类似功能的。
 4. 字节码生成
 