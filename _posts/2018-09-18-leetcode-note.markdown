---
layout:     post
title:      "LeetCode解题笔记"
subtitle:   "hard难度题解"
date:       2018-09-18
author:     "brucechen"
header-img: "img/post-bg-java.jpg"
published: true
tags:
    - 算法
    - 读书笔记
---

最近把LeetCode上面hard难度的题目全部刷了一遍，碰到了很多不会的类型，因此把解题思路全部整理一下。

题解的源码[github](https://github.com/Brucechen13/algocodes/tree/master/codes/src/algo/leetcode)

### Longest Valid Parentheses

给出只包含`(`和`)`的字符串，要求找出最长的连续合法括号组的子串长度。

解法：

    只需要通过栈来对字符进行处理，当遇到`(`,入栈下标位置，当遇到`)`，如果栈顶是`(`，则出栈，否则入栈下标位置。
    当全部字符都入栈后，如果栈元素个数为0，则全部为合法括号组，否则，依次出栈元素，元素之间的差值就是这两个字符之间合法括号组的长度，找出最大的差值就可。


### Sudoku Solver ***

9x9数独问题，每行、每列、每宫3x3格子必须包含1-9.

解法：

    最简单的方法就是直接对每个位置进行搜索，判断每个位置的数字是否符合要求，直到所有的格子都搜索完毕。

    数独问题的还可以通过DLX算法来求解，将数独问题转换为精确覆盖问题。
    使用81列约束每个格子都要填一个数字，使用81列约束每行1-9都要填一遍，使用81列约束每列1-9都要填一遍，最后使用81列约束每宫1-9都要填一遍，一共使用324列来约束数独问题。


### First Missing Positive **

给一个未排序的整数数组，找出最小的不存在的整数。要求O(N)时间复杂度和常数复杂度

解法：

    最简单的解法创建长度与数组一样的标记数组，对每一个整数数组在标记数组对应的下标处标记，如果超过长度则不处理，最后从前往后遍历找出缺失的元素。

    但是这道题要求常数复杂度，所以一种改进的方法是在原数组上进行修改，从前往后遍历，使得 A[A[i]-1]=A[i] 。

    上面这种方法需要修改原数组，不修改原数组也可以做到。首先把原数组中小于等于0的数加上数组的最大值，使得原数组全部元素都为正整数。然后使得A[A[i]-1]=-abs(A[A[i]-1)。然后遍历数组，如果下标i的A[i]大于0则说明i+1的数不存在。最后重置数组，A[i]=abs(A[i])

### Trapping Rain Water **

给出n个非负整数代表墙壁的高度，计算当前的建筑最多可以存储多少水。

解法：

    使用单调减栈，每当当前高度比栈顶的高度要高时，弹出栈顶元素，添加栈顶位置到当前位置之间的存水量。

    更好的方法就是我们不再仅仅从一边开始计算，而是使用两个指针，分别从左右两边开始向中间推进，计算两边的存水量。


### Trapping Rain Water II ****

2维空间计算存水量，给出一个n*m的矩阵，每个元素代表高度，求最大储水量

解法：

    使用基于高度的优先队列+BFS，从四周向中间搜索，计算储水量。



### Wildcard Matching **

给出两个字符串s,p,要求返回s是否可以由p全部匹配。p字符串是通配符字符串，包含`?`和`*`，分别代表匹配任一字符和匹配任意多字符。

解法：

    可以使用dp算法，dp[i][j]表示s[:i]和p[:j]是否匹配，匹配为1，不匹配为0
    状态转移方程如下：
    dp[i][j] =  
    
                dp[i-1][j-1], if s[i] == s[j] or s[j] == '*' or s[j] == '?'
                
                dp[i-1][j] if s[j] == '*'

                dp[i][j-1] if s[j] == '*' and j > 0
 


### Jump Game II

给出一个非负整数数组，代表在每个位置你可以前进的最大长度，你的初始位置在0，求出最少需要多少步可以走到最后的位置。

解法：

     每次走一步，判断最远可以走到哪里，如果可以走到最后，则返回走的步数。


### N-Queens

经典N皇后问题，nxn的棋盘放置n个棋子，要求任意两个棋子不在同一行、同一列、同一斜线。

解法：

    可以采用搜索，判断每个格子是否可以放置棋子。
    为了提高效率，可以采用三个数组来保存不能访问的位置usedRow, diagonalOne, diagonalTwo.
    usedRow[i]表示i行被访问
    diagonalOne[i+col]表示对角线被访问
    diagonalTwo[i-col+matrix.length-1]表示对角线被访问


### Edit Distance **

给出两个字符串，求出最少的操作使得第一个字符串可以转换为第二个字符串。操作有：
1. 插入字符
2. 删除字符
3. 替换字符

解法：
    
    经典的DP问题
    最容易想到的是利用二维数组dp[i][j]，表示s1[:i]和s2[:j]的最小编辑距离。
    dp[i][j]=   dp[i-1][j-1] if s1[i] == s2[j]
                min(dp[i][j-1], dp[i-1][j-1], dp[i-1][j]) + 1
    
    也可以进行优化使用一维数组进行dp.由于上述状态转移每次只用到dp[i-1][j-1], dp[i-1][j], dp[i][j-1],可以使用一维数组dp[j]，dp[i[j-1]使用临时变量存储，每次用到dp[j-1], dp[j], tmp。



### Minimum Window SubString ***

给出两个字符串S,T,要求找出S中最短的连续子串使得子串包含T中所有字符。

解法：

    使用两个下标i,j分别表示S访问到的下标和S开始的下标，统计T中每个字符的数量，当遍历S时，每次在对应的字符位置上减一，如果T该字符的数量为0，T的数量减一。如果T的数量为0，表示S从j到i的位置上已经全部包含T字符串，记录子串的长度，同时j++,j位置上的字符数量加一。依次遍历S，找出最短的子串。


### Largest Rectangle in Histogram

给出N个非负整数表示直方图，求出直方图中最大长方形的区域。

解法：

    使用单调递增栈依次存储，当遇到一个比栈顶小的元素时，依次弹出所有大于给定元素的值，计算已入栈的元素最大区域，最大区域就是弹出的元素x前面的长度。最后与0比较，弹出所有元素。


### Maximal Rectangle **

给出二维0-1矩阵，找出最大只包含1的矩形并返回区域面积。

解法：

    按照行遍历，每次统计上面最高的距离，左边最远的距离和右边最远的距离，计算面积

    也可以预处理成一个求海平面上柱状图的最大面积的问题，然后用单调栈



### Interleaving String **

给出三个字符串s1,s2,s3,计算s3是否可以由s1,s2交叉组合而成。

解法：

    使用搜索，每次如果s1[i]==s3[k]或s2[j]==s3[k]则依次向后搜索。

    也可以使用dp,dp[i][j]表示s1[:i]+s2[:j]==s3[:i+j],二维dp还可以优化为一维dp.



### Recover Binary Search Tree **

二叉搜索树的两个节点被错误的交换了，要求不改变表结构更正过来。

解法：

    中序遍历搜索，找出所有不满足搜索树条件的节点，将他们的值交换。


### Distinct SubSequences **

给出两个字符串S,T,找出S中等于T的子串数量。

解法：

    使用DP算法，dp[i][j]表示S[:i]和T[:j]的子串数量。
    dp[i][j] =  dp[i-1][j]
                dp[i-1][j-1] if S[i-1] == T[j-1]


### Best Time to Buy and Sell Stock III

给出N个整数数组代表股票的价格，你至多可以完成两笔交易，求出最大的收益

解法：

    如果只能完成一笔交易，只需要找出最小的买进和最大的卖出。
    两笔交易只需要通过两个买进和两个卖出就可以计算。

### Best Time to Buy and Sell Stock IV ***




### Bianry Tree Maximum Path Sum

给出一个二叉树，求出最大路径和。

解法:

    从根节点依次遍历，每次统计当前节点为中介的最大路径和，找出最大值就可。


### Word Ladder II

给出两个单词S, E,和一个字典，要求每次只改变S其中一个字符且修改后的单词在字典中存在，求出所有可能的修改路劲

解法：

    首先构建出从单词S开始可以转换的单词组合
    然后使用深度优先搜索，找出所有能变为E的组合


### Longest Consecutive Sequence ***

给出一个未排序的整数数组，找出最长的连续元素序列。如给出输入`[100,4,200,1,3,2]`，则最长连续序列为`[4,1,3,2]`,输出4.

解法：

    解法一：直接排序，找出每个连续的序列的长度，输出最大长度。但这种方法时间复杂度为O(NLOGN)

    解法二：使用并查集，将连续的数字看成一个集合，找出每个集合的元素，返回最大值，时间复杂度为O(N)


### Palindrome Partitioning II **

给出字符串S，要求将S分割为若干个子字符串，使得每个子字符串都是回文字符串，求出分割的最少次数。

解法：

    解法一：使用搜索，每次对探索字符串S,如果S[:i]为回文字符串，继续探索后面的最少次数。

    解法二：从前往后遍历S的每个下标，对于每个下标都向两边找以下标为中心的偶数回文字符串和奇数回文字符串，修改每个位置的最少次数f[right] = Math.min(f[right], f[left-1] + 1);



### Candy

N个小孩做成一排，每个位置有一个整数代表这个小孩需要比旁边小孩有更多糖果的优先级，每个小孩至少一个糖果

解法：

    使用辅助数组，每次根据优先级更新数组上糖果数，最后统计和。

### Word Break II **

给出字符串S和字典，要求将字符串S分割成若干个子字符串，使得每个子字符串都存在于字典，求出所有分割方法。

解法：

    解法一：直接搜索，对字符串S找出所有在字典中的子串，然后搜索剩余字符串。

    解法二：解法一的搜索会出现很多无效情况，比如剩余字符串如果已经探索过不合法，那就不需要继续探索了，所以缓存S每个下标是否合法，如果已经探索过不合法，直接跳过。


### Word Search II

给出一个二维棋盘，棋盘每个位置都是一个字符，以及一个字典，要求找出所有棋盘上毗邻的字符且存在字典中的字符串

解法：

    构建字典树，然后BFS

### Binary Tree Postorder Traversal

返回二叉树的后序访问结果

解法：

    Morris 遍历


### LRU Cache ***

设计一个LRU结果，要求支持`get`和`put`操作。而且还要满足超容量淘汰。要求符合O(1)时间复杂度。

解法：

    使用hashmap+带头尾指针的双向链表，每次更新时把根据hashmap找到元素提到最前，每次淘汰时找到链尾元素删除。


### Max Points On a Line

给出n个2维平面上的点，找出最多在同一直线上的点

解法：

    两层循环遍历找出任意两个点之间的斜率，通过hashmap存储斜率与点数的关系。


### Find Minimum in Rotated Sorted Array II **

一个排序数组按照某个下标进行了旋转，要求找出旋转后数组的最小元素。

解法：

    二分查找，根据两端和中间元素的大小进行讨论

### Maximum Gap ***

给出未排序的整数数组，找出排序后相邻元素的最大差，要求O(N)时间复杂度

解法：

    将N个数按照大小等分到N-1个桶中，每个桶保存桶内最大值和最小值，两个桶之间的最大值最小值之差就是相对的最大差候选。

### Shortest Palindrome ***

给出字符串S，可以在前面添加任意多字符，要求添加最少字符使得添加后的字符串是一个回文字符串。

解法：

    找出字符串S开始与后面一样的字符数量，然后递归