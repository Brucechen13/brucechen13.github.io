---
layout:     post
title:      "LeetCode解题笔记"
subtitle:   "hard难度题解"
date:       2018-09-18
author:     "brucechen"
header-img: "img/post-bg-java.jpg"
published: true
tags:
    - 算法
    - 读书笔记
---

最近把LeetCode上面hard难度的题目全部刷了一遍，碰到了很多不会的类型，因此把解题思路全部整理一下。

题解的源码[github](https://github.com/Brucechen13/algocodes/tree/master/codes/src/algo/other)

### Longest Valid Parentheses

给出只包含`(`和`)`的字符串，要求找出最长的连续合法括号组的子串长度。

解法：

    只需要通过栈来对字符进行处理，当遇到`(`,入栈下标位置，当遇到`)`，如果栈顶是`(`，则出栈，否则入栈下标位置。
    当全部字符都入栈后，如果栈元素个数为0，则全部为合法括号组，否则，依次出栈元素，元素之间的差值就是这两个字符之间合法括号组的长度，找出最大的差值就可。


### Sudoku Solver ***

9x9数独问题，每行、每列、每宫3x3格子必须包含1-9.

解法：

    最简单的方法就是直接对每个位置进行搜索，判断每个位置的数字是否符合要求，直到所有的格子都搜索完毕。

    数独问题的还可以通过DLX算法来求解，将数独问题转换为精确覆盖问题。
    使用81列约束每个格子都要填一个数字，使用81列约束每行1-9都要填一遍，使用81列约束每列1-9都要填一遍，最后使用81列约束每宫1-9都要填一遍，一共使用324列来约束数独问题。


### First Missing Positive **

给一个未排序的整数数组，找出最小的不存在的整数。要求O(N)时间复杂度和常数复杂度

解法：

    最简单的解法创建长度与数组一样的标记数组，对每一个整数数组在标记数组对应的下标处标记，如果超过长度则不处理，最后从前往后遍历找出缺失的元素。

    但是这道题要求常数复杂度，所以一种改进的方法是在原数组上进行修改，从前往后遍历，使得 A[A[i]-1]=A[i] 。

    上面这种方法需要修改原数组，不修改原数组也可以做到。首先把原数组中小于等于0的数加上数组的最大值，使得原数组全部元素都为正整数。然后使得A[A[i]-1]=-abs(A[A[i]-1)。然后遍历数组，如果下标i的A[i]大于0则说明i+1的数不存在。最后重置数组，A[i]=abs(A[i])

### Trapping Rain Water **

给出n个非负整数代表墙壁的高度，计算当前的建筑最多可以存储多少水。

解法：

    使用单调减栈，每当当前高度比栈顶的高度要高时，弹出栈顶元素，添加栈顶位置到当前位置之间的存水量。

    更好的方法就是我们不再仅仅从一边开始计算，而是使用两个指针，分别从左右两边开始向中间推进，计算两边的存水量。


### Trapping Rain Water II ****

2维空间计算存水量，给出一个n*m的矩阵，每个元素代表高度，求最大储水量

解法：

    使用基于高度的优先队列+BFS，从四周向中间搜索，计算储水量。



### Wildcard Matching **

给出两个字符串s,p,要求返回s是否可以由p全部匹配。p字符串是通配符字符串，包含`?`和`*`，分别代表匹配任一字符和匹配任意多字符。

解法：

    可以使用dp算法，dp[i][j]表示s[:i]和p[:j]是否匹配，匹配为1，不匹配为0
    状态转移方程如下：
    dp[i][j] =  
    
                dp[i-1][j-1], if s[i] == s[j] or s[j] == '*' or s[j] == '?'
                
                dp[i-1][j] if s[j] == '*'

                dp[i][j-1] if s[j] == '*' and j > 0
 


### Jump Game II

给出一个非负整数数组，代表在每个位置你可以前进的最大长度，你的初始位置在0，求出最少需要多少步可以走到最后的位置。

解法：

     每次走一步，判断最远可以走到哪里，如果可以走到最后，则返回走的步数。


### N-Queens

经典N皇后问题，nxn的棋盘放置n个棋子，要求任意两个棋子不在同一行、同一列、同一斜线。

解法：

    可以采用搜索，判断每个格子是否可以放置棋子。
    为了提高效率，可以采用三个数组来保存不能访问的位置usedRow, diagonalOne, diagonalTwo.
    usedRow[i]表示i行被访问
    diagonalOne[i+col]表示对角线被访问
    diagonalTwo[i-col+matrix.length-1]表示对角线被访问
