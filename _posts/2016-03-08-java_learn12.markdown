---
layout:     post
title:      "深入理解JAVA虚拟机学习笔记"
subtitle:   "第13章 线程安全与锁优化"
date:       2016-03-08
author:     "brucechen"
header-img: "img/post-bg-java.jpg"
published: false
tags:
    - Java
    - 读书笔记
---

### 线程安全
当多个线程访问同一个对象时，如果不用考虑这些线程在运行时环境的调度与交替执行，也不需要进行额外的同步操作，或者调用方进行其他的协调操作，调用这个对象总可以获取正确的结果，那么这个对象就是线程安全的。
Java语言中各种操作共享的数据可以分为5类：
* 不可变，如果共享数据是基本数据类型，只要在定义时加上final关键字修饰就可以保证不可变，如果共享数据是一个对象，就需要保证对象的行为不会对其状态产生任何影响。简单的实现就是将对象中带有状态的变量都设为final。
* 绝对线程安全，意味着不管运行时环境如何，调用者都不需要任何同步措施。
* 相对线程安全，通常意义的线程安全，需要保证对象的单独操作是绝对线程安全的，但是一些特定顺序的连续调用可能需要调用方使用额外的同步手段来确保调用的正确。
* 线程兼容
对象本身不是线程安全的，需要调用方进行同步。
* 线程对立，无论调用方如何同步，都无法在多线程环境中并发使用的代码。由于Java语言天生具备多线程特性，线程对立的代码很少出现，而且通常是有害的。

#### 线程安全的实现方法
对于实现线程同步，除了代码的编写，虚拟机本身也提供了十分重要的同步与锁机制。
* 互斥同步，临界区、互斥量和信号量都是主要的互斥实现方式。Java中最基本的互斥同步手段是synchronized关键字，经过编译后，会在同步块前后分别形成monitorenter和moniterexit字节码指令，这两个字节码都需要一个reference类型参数指明锁定的对象。 synchronized同步对同一条线程是可重入的，不会出现自己把自己锁死的情况。同步块会阻塞其他线程进入，Java的线程是映射到操作系统原生线程上的，所以阻塞唤醒线程需要操作系统实现，从用户态转换到内核态，开销较大。虚拟机本身会对阻塞过程做一些优化，如加入自旋等待过程。
* 除了synchronized，还可以使用concurrent包中的重入锁（`ReentrantLock`）实现同步。ReentrantLock提供了以下高级功能：

 + 等待可中断，当持有锁的线程长期不释放锁时，等待的线程可以放弃等待，改为处理其他事情。
 + 公平锁，多个线程等待同一个锁时，必须按照申请锁的时间来获取锁；不公平锁不保证这一点，锁释放时，任何一个等待锁的线程都有可能获取锁。synchronized锁是非公平的，ReentrantLock默认也是非公平的。
 + 绑定多个条件，ReentrantLock对象可以同时绑定多个Condition对象。
 
JDK1.6之前，由于synchronized本身优化不够，ReentrantLock的性能相对较好，JDK1.6后，性能已不再是选择ReentrantLock的理由。