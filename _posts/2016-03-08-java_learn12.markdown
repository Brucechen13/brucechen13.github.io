---
layout:     post
title:      "深入理解JAVA虚拟机学习笔记"
subtitle:   "第13章 线程安全与锁优化"
date:       2016-03-08
author:     "brucechen"
header-img: "img/post-bg-java.jpg"
published: false
tags:
    - Java
    - 读书笔记
---

### 线程安全
当多个线程访问同一个对象时，如果不用考虑这些线程在运行时环境的调度与交替执行，也不需要进行额外的同步操作，或者调用方进行其他的协调操作，调用这个对象总可以获取正确的结果，那么这个对象就是线程安全的。
Java语言中各种操作共享的数据可以分为5类：
* 不可变，如果共享数据是基本数据类型，只要在定义时加上final关键字修饰就可以保证不可变，如果共享数据是一个对象，就需要保证对象的行为不会对其状态产生任何影响。简单的实现就是将对象中带有状态的变量都设为final。
* 绝对线程安全，意味着不管运行时环境如何，调用者都不需要任何同步措施。
* 相对线程安全，通常意义的线程安全，需要保证对象的单独操作是绝对线程安全的，但是一些特定顺序的连续调用可能需要调用方使用额外的同步手段来确保调用的正确。
* 线程兼容
对象本身不是线程安全的，需要调用方进行同步。
* 线程对立，无论调用方如何同步，都无法在多线程环境中并发使用的代码。由于Java语言天生具备多线程特性，线程对立的代码很少出现，而且通常是有害的。

#### 线程安全的实现方法
对于实现线程同步，除了代码的编写，虚拟机本身也提供了十分重要的同步与锁机制。
* 互斥同步，临界区、互斥量和信号量都是主要的互斥实现方式。Java中最基本的互斥同步手段是synchronized关键字，经过编译后，会在同步块前后分别形成monitorenter和moniterexit字节码指令，这两个字节码都需要一个reference类型参数指明锁定的对象。 synchronized同步对同一条线程是可重入的，不会出现自己把自己锁死的情况。同步块会阻塞其他线程进入，Java的线程是映射到操作系统原生线程上的，所以阻塞唤醒线程需要操作系统实现，从用户态转换到内核态，开销较大。虚拟机本身会对阻塞过程做一些优化，如加入自旋等待过程。
* 除了synchronized，还可以使用concurrent包中的重入锁（`ReentrantLock`）实现同步。ReentrantLock提供了以下高级功能：

 + 等待可中断，当持有锁的线程长期不释放锁时，等待的线程可以放弃等待，改为处理其他事情。
 + 公平锁，多个线程等待同一个锁时，必须按照申请锁的时间来获取锁；不公平锁不保证这一点，锁释放时，任何一个等待锁的线程都有可能获取锁。synchronized锁是非公平的，ReentrantLock默认也是非公平的。
 + 绑定多个条件，ReentrantLock对象可以同时绑定多个Condition对象。
 
JDK1.6之前，由于synchronized本身优化不够，ReentrantLock的性能相对较好，JDK1.6后，性能已不再是选择ReentrantLock的理由。

### 锁优化

#### 自旋锁与自适应锁
同步所造成的线程阻塞需要用户态与内核态的切换才能实现，而且许多共享数据的锁定只有很短时间，所以可以让后面等待锁的线程不阻塞，而是去执行一个忙循环，等待锁的释放，这种技术就叫做自旋锁。
自旋锁需要控制好自旋等待的时间，否则就会消耗过多的处理器资源。JDK1.6之后引入了自适应的自旋锁，自旋时间由前一次在同一个锁的自旋时间和拥有着本身的状态决定。

#### 锁消除
如果判断一段代码中堆的所有数据都不会逃逸出去被其他线程访问，那就可以当作栈上数据处理，无需进行同步加锁。

#### 锁粗化
如果一系列的操作都是对同一个对象反复加锁解锁，甚至加锁操作出现在循环体中，那即使没有线程竞争，频繁的互斥同步操作也会导致不必要的性能损失，这时可以将锁的范围扩大。

#### 轻量级锁
轻量级锁只是在没有线程竞争的情况下使用，减少重量级锁的系统互斥操作。
轻量级锁的实现通过对象在堆中的markword对象头信息实现。Mark Word中除了存储对象哈希码、分代年龄还存储了锁标记存储位，如下：

![java-javascript](/img/in-post/java-virtual-machine/java-markword.jpg)
<small class="img-hint">HotSpot虚拟机对象头MarkWord</small>

当代码进入同步块时，如果同步对象没有锁定（标志位为`01`），虚拟机首先在当前线程的帧栈中建立一个锁记录，用于存储锁对象目前Mark Word的拷贝。然后虚拟机使用CAS操作尝试将对象的Mark Word更新为锁记录的指针，如果成功，线程就拥有了该对象的锁，对象的Mark Word锁标志位转为`00`，表明当前处于轻量级锁状态，如果更新操作失败了，虚拟机首先会检查对象的Mark Word是否指向当前线程的帧栈，如果指向则说明当前线程已经拥有的这个对象的锁，直接进入同步块继续执行，否则说明锁对象被其他线程抢占了，两条以上的线程争用同一个锁，轻量级锁不再有效，膨胀为重量级锁，标志位变为`10`，后面等待锁的线程进入阻塞状态。
解锁过程同样是通过CAS操作进行，如果锁对象的Mark Word指向线程的锁记录，通过CAS操作把对象当前的Mark Word和线程复制的替换回来，如果替换成功，同步结束，否则说明其他线程尝试获取该锁。释放锁的同时唤醒被挂起的线程。

#### 偏向锁
偏向锁是轻量级锁的进一步轻量级化，在无竞争的情况下连CAS操作都无需使用。偏向锁会偏向第一个获取它的线程，将标志位置为`01`，同时使用CAS操作把锁的线程ID记录在对象的Mark Word之中，如果CAS操作成功，持有锁的线程以后进入锁相关的同步块都不需任何同步操作。
当另外线程尝试获取这个锁时，偏向模式结束，根据锁对象当前是否处于被锁定状态，撤销恢复到未锁定或轻量级锁定状态。